# -*- coding: utf-8 -*-
"""code_simulation_stratification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y8ny_PzaRyPPysG76cwzDSLdICUn__P0
"""

import numpy as np

# ==========
# Utilitaires
# ==========

EPS = 1e-12

def clamp_den(x, eps=EPS):
    return x if abs(x) > eps else (np.sign(x) * eps if x != 0 else eps)

def d_dx_central(arr, i, dx):
    """Dérivée spatiale centrale ∂/∂x (arr indexé en x), avec garde simple aux bords."""
    if i == 0:
        return (arr[1] - arr[0]) / dx
    if i == len(arr) - 1:
        return (arr[i] - arr[i-1]) / dx
    return (arr[i+1] - arr[i-1]) / (2.0 * dx)

# ==============================
# COUCHE LIMITE (mécanique/flux)
# ==============================

def Ub(g, beta, Tw, TB, nu):
    """Vitesse caractéristique de couche limite (profil intégral)."""
    return (g * beta * (Tw - TB) * nu) ** (1/3)

def Grashof_x(g, beta, Tw, TB, x, nu):
    """Grashof local Gr_x."""
    return (g * beta * (Tw - TB) * x**3) / (nu**2)

def tau_w_lam(rho, ub, g, beta, Tw, TB, x, nu):
    """Contrainte pariétale laminaire (Tsuji–Nagano, Gr < 1e9)."""
    Grx = Grashof_x(g, beta, Tw, TB, x, nu)
    return rho * (ub**2) * 0.953 * (Grx ** (1/12))

def tau_w_turb(rho, ub, g, beta, Tw, TB, x, nu):
    """Contrainte pariétale turbulente (Tsuji–Nagano, Gr > 1e9)."""
    Grx = Grashof_x(g, beta, Tw, TB, x, nu)
    return rho * (ub**2) * 0.684 * (Grx ** (1/11.9))

def Rayleigh_x(g, alpha, Tw, TB, x, nu, a):
    """Ra_x = g α (Tw-TB) x^3 / (ν a)."""
    return (g * alpha * (Tw - TB) * x**3) / (nu * a)

def k_nat_1e5_1e9(Rax, lambda_l, x):
    """k pour 1e5 < Ra < 1e9 : Nu = 0.59 Ra^(1/4)."""
    return 0.59 * (Rax ** 0.25) * (lambda_l / clamp_den(x))

def k_nat_1e9_1e13(Rax, lambda_l, x):
    """k pour 1e9 < Ra < 1e13 : Nu = 0.11 Ra^(1/3)."""
    return 0.11 * (Rax ** (1/3)) * (lambda_l / clamp_den(x))

def q_in_wall(Tw, TB, Rax, x, lambda_l):
    """
    Flux pariétal entrant q'' = k (Tw - TB), avec sélection de corrélation selon Ra_x.
    Hors plage, on prolonge prudemment la corrélation 1e5–1e9.
    """
    dT = (Tw - TB)
    if 1e5 < Rax <= 1e9:
        k = k_nat_1e5_1e9(Rax, lambda_l, x)
    elif 1e9 < Rax <= 1e13:
        k = k_nat_1e9_1e13(Rax, lambda_l, x)
    else:
        k = k_nat_1e5_1e9(max(Rax, 1e5), lambda_l, max(x, EPS))
    return k * dT

def k_propane_liq(T):
    """Conductivité thermique [W/m/K] du propane liquide (230–320 K)."""
    return max(0.146 - 1.8e-4 * T, 0.05)

def k_propane_vap(T):
    """Conductivité thermique [W/m/K] du propane vapeur (250–350 K)."""
    return 7.2e-3+3.5e-5*T

# ==================================
# Variables normalisées dans la CL : η
# ==================================

def eta_moy(T_tilde, TB, Tw):
    """η = (T̃ - TB)/(Tw - TB)."""
    return (T_tilde - TB) / clamp_den(Tw - TB)

def d_eta_dt(i, dTtilde_dt, dTw_dt, dTB_dt, Tw, TB, eta_i, ddelta_dt):
    """
    dη_i/dt — si dδ/dt >= 0 : 0
             sinon : ( dT̃/dt - η dTw/dt + (1-η) dTB/dt ) / (Tw - TB)
    """
    if ddelta_dt >= 0.0:
        return 0.0
    denom = clamp_den(Tw[i] - TB[i])
    return (dTtilde_dt - eta_i * dTw_dt + (1.0 - eta_i) * dTB_dt) / denom

# =================================================
# Équations intégrales de la couche limite (énergie)
# =================================================

def dTtilde_dt(i, eta, dTw_dt, dTB_dt,
               Tw, TB,
               ddelta_dt,
               m_dot, m_dot_y, h_tilde, h_y,
               q_in_i, R, Hcv, rho, cv, delta_i):
    """
    dT̃_i/dt :
    - si dδ/dt >= 0:  η_i dTw/dt + (1-η_i) dTB/dt  (car dη/dt=0 dans ce cas)
    - sinon: ( ṁ_i h̃_i - ṁ_{i-1} h̃_{i-1} - ṁ_{y,i} h_{y,i} + 2π R Hcv q_in,i )
             / ( 2π R ρ c_v Hcv δ_i )
    """
    if ddelta_dt >= 0.0:
        return eta[i] * dTw_dt + (1.0 - eta[i]) * dTB_dt

    num = (m_dot[i] * h_tilde[i]
           - m_dot[i-1] * h_tilde[i-1]
           - m_dot_y[i] * h_y[i]
           + 2.0 * np.pi * R * Hcv * q_in_i)
    den = 2.0 * np.pi * R * rho * cv * Hcv * clamp_den(delta_i)
    return num / den

def ddelta_dt_from_energy(i,
                          dTtilde_dt_i,                # valeur scalaire déjà calculée
                          m_dot, m_dot_y, h_tilde, h_y,
                          q_in_i, R, Hcv, rho, cv,
                          delta_i, T_tilde_i, TB_i):
    """
    dδ_i/dt via l’équation d’énergie intégrale (forme “Eq.15” réarrangée) :
    ρ cv [ δ dT̃/dt + (T̃ - TB) dδ/dt ] = ( ṁ h̃ - ṁ_- h̃_- - ṁ_y h_y )/(2πR Hcv) - q_in
    ⇒ dδ/dt = [ (m-terms)/(2πR Hcv ρ cv) - q_in/(ρ cv) - δ dT̃/dt ] / (T̃ - TB)
    """
    m_terms = (m_dot[i] * h_tilde[i]
               - m_dot[i-1] * h_tilde[i-1]
               - m_dot_y[i] * h_y[i])
    A = (m_terms / (2.0 * np.pi * R * Hcv * rho * cv)) - (q_in_i / (rho * cv)) - delta_i * dTtilde_dt_i
    return A / clamp_den(T_tilde_i - TB_i)

# ======================================
# Masse/Énergie dans le BULK (liquide)
# ======================================

def bilan_masse_bulk(mB, m_dot_y_i):
    """Équilibre masse local (retourne mB_i - ṁ_y,i) si besoin d’un résidu."""
    return mB - m_dot_y_i

def dTB_dt_bulk(i, lambdaB, R, rho, cv,
                TB, delta, dx,
                m_dot_B, m_dot_y, h_y, h_B,
                T_top=None):
    """
    dTB/dt (bulk) avec conduction axiale + advection (CV annulaire).
    Si i == N-1 et T_top fourni : ∂TB/∂x ≈ (TB[i] - T_top)/dx (BC Dirichlet).
    Tous les termes sont contraints en scalaire pour éviter les retours vecteur.
    """
    # force 1D float
    TB      = np.asarray(TB,      dtype=float).reshape(-1)
    delta   = np.asarray(delta,   dtype=float).reshape(-1)
    m_dot_B = np.asarray(m_dot_B, dtype=float).reshape(-1)
    m_dot_y = np.asarray(m_dot_y, dtype=float).reshape(-1)
    h_y     = np.asarray(h_y,     dtype=float).reshape(-1)
    h_B     = np.asarray(h_B,     dtype=float).reshape(-1)

    N = len(TB)
    area_i = float(np.pi * (R - delta[i])**2)

    # dTB/dx au point i
    if (i == N-1) and (T_top is not None):
        dTBdx_i = float((TB[i] - float(T_top)) / dx)
    else:
        dTBdx_i = float(d_dx_central(TB, i, dx))
    dTBdx_im1 = float(d_dx_central(TB, max(i-1, 0), dx))

    # numérateur (scalaires)
    num = ( float(m_dot_B[i]) * float(h_B[i])
          - float(m_dot_B[i-1]) * float(h_B[i-1])
          - float(m_dot_y[i]) * float(h_y[i])
          + area_i * float(lambdaB) * (dTBdx_i - dTBdx_im1) )
    den = area_i * float(rho) * float(cv) * float(dx)

    return num / clamp_den(den)


# ==================================
# Interface liquide/vapeur (échanges)
# ==================================

def Rayleigh_v_int(g, alpha_v, Tv, Tint, D, nu_v, rho_v,cp_v,lambda_vapeur):
    return (g * alpha_v * (Tv - Tint) * D**3*rho_v*cp_v) / (nu_v *lambda_vapeur)

def Rayleigh_l_int(g, alpha_l, Ts, Tint, D, nu_l, a_l):
    return (g * alpha_l * (Tint - Ts) * D**3) / (nu_l * a_l)

def k_v_int(Ra_v_int, D, lambda_v):
    """k côté vapeur à l’interface."""
    return 0.54 * (Ra_v_int ** 0.25) * (lambda_v / clamp_den(D))

def k_l_int(Ra_l_int, D, lambda_l):
    """k côté liquide à l’interface."""
    return 0.27 * (Ra_l_int ** 0.25) * (lambda_l / clamp_den(D))

def m_dot_phase(R, gamma, Tv, Ts, Tint, k_v_int_val, k_l_int_val):
    """
    ṁ_ph = π R^2 [ k_v-int (Tv - Tint) - k_l-int (Tint - Ts) ] / γ
    (γ = chaleur latente)
    """
    return np.pi * R**2 * (k_v_int_val * (Tv - Tint) - k_l_int_val * (Tint - Ts)) / clamp_den(gamma)

def dHs_dt(m_dot_ph, rho_l, R):
    """dH_s/dt = ṁ_ph / (ρ_l π R^2)."""
    return m_dot_ph / (rho_l * np.pi * R**2)

def dTs_dt_surface(n,
                   m_dot_B, h_B,           # tableaux sur x
                   m_dot, h_tilde,         # CL en haut (ṁ_n, h̃_n)
                   R, H_s, qin_s,          # géométrie/surface & flux paroi -> surface
                   kint_liq,               # k_int->liq (interface -> liquide)
                   T_int, T_s,             # températures interface & surface
                   delta, lambda_B, T_B,   # bulk: épaisseur CL (delta), λ_B, T_B(x)
                   dx,                     # pas spatial pour dT_B/dx
                   dH_s_dt                 # déjà calculé via dHs_dt(...)
                   ):
    """
    Retourne dT_s/dt sur le CV de surface (équation énergie surface).
    Hypothèses : continuité ṁ_n = ṁ_B[n]
    """
    # Aires utiles
    area_surf = np.pi * R**2
    area_bulk = np.pi * (R - delta[n])**2

    # Termes "masse * enthalpie" (entrée depuis CL, sortie vers bulk)
    term_mass = m_dot[n] * h_tilde[n] - m_dot_B[n] * h_B[n]

    # Flux pariétal intégré le long de H_s (paroi -> surface)
    term_wall = 2.0 * np.pi * R * H_s * qin_s

    # Échange interfacial (interface -> surface liquide)
    term_int = area_surf * kint_liq * (T_int - T_s)

    # Conduction vers le bulk (gradient amont simple)
    dTBdx_n = (T_B[n] - T_B[n-1]) / dx if n > 0 else (T_B[1] - T_B[0]) / dx
    term_cond_bulk = - area_bulk * lambda_B * dTBdx_n

    # Numérateur / dénominateur de l’équation (29)
    num = term_mass + term_wall + term_int + term_cond_bulk
    den = area_surf * max(H_s, 1e-12)

    # Terme dû au mouvement de frontière (H_s variable) : -(T_s - T_int) * dH_s/dt / H_s
    return (num / den) - ( (T_s - T_int) * dH_s_dt / max(H_s, 1e-12) )

def Tsat_de_P_Clausius(Pv_pa, Pref_pa, Tref_K, dh_vap_J_per_kg, M_kg_per_mol):
    """
    Fermeture analytique: T_sat(P) avec Δh_vap ~ cte.
    - Pv_pa : pression cible (Pa)
    - Pref_pa, Tref_K : point de référence (e.g. (1 atm, T_ebullition))
    - dh_vap_J_per_kg : chaleur latente (J/kg)
    - M_kg_per_mol : masse molaire
    """
    R_u = 8.314462618  # J/mol/K
    R_spec = R_u / M_kg_per_mol
    invT = (1.0/Tref_K) - (R_spec/dh_vap_J_per_kg) * np.log(Pv_pa / Pref_pa)
    return 1.0 / invT


# ======================
# Dôme vapeur (gaz parfait)
# ======================

def dTv_dt(kwv, Aw, Twv, Tv, k_v_int_val, Tint, cv_v, Vv, rho_v):
    """
    dTv/dt = (k_wv A_w (Twv - Tv) - π R^2 k_v-int (Tv - Tint)) / (Vv ρ_v c_v)
    NB : la surface πR^2 doit être passée via le produit (k_v_int_val) déjà multiplié si tu préfères.
    """
    return (kwv * Aw * (Twv - Tv) - k_v_int_val * (Tv - Tint)) / clamp_den(Vv * rho_v * cv_v)

def dP_dt(Tv, m_dot_ph, Vv, Pv, dTv_dt_val, r_spec, rho_l):
    """
    dP/dt pour un gaz parfait (ρ_v = P/(r Tv)) :
      Vv (∂ρ/∂P dP/dt + ∂ρ/∂T dT/dt) = ṁ_ph (1 - ρ_v/ρ_l)
      ⇒ Vv(1/(r Tv)) dP/dt - Vv(P/(r Tv^2)) dTv/dt = ṁ_ph (1 - P/(r Tv ρ_l))
      ⇒ dP/dt = [ ṁ_ph (1 - P/(r Tv ρ_l)) + Vv (P/(r Tv^2)) dTv/dt ] / [ Vv/(r Tv) ]
    """
    left  = Vv / clamp_den(r_spec * Tv)
    termT = Vv * (Pv / clamp_den(r_spec * (Tv**2))) * dTv_dt_val
    rhs   = m_dot_ph * (1.0 - Pv / clamp_den(r_spec * Tv * rho_l))
    return (rhs + termT) / left

# ==========
#   Paroi
# ==========

def dTw_dt_liq(i, qext_i, qin_i, delta_w, c_w, lambda_w, Tw, rho_w, dx):
    """
    dTw_i/dt côté liquide : (q_ext - q_in)/(δ_w ρ_w c_w) + (λ_w / (ρ_w c_w)) Δ_x Tw
    avec Δ_x Tw ≈ (T[i+1] - 2T[i] + T[i-1]) / dx^2 (schéma 3 points).
    """
    if i == 0:
        lap = (Tw[1] - Tw[0]) / (dx**2)       # bord bas (simple unilatéral)
    elif i == len(Tw) - 1:
        lap = (Tw[i] - Tw[i-1]) / (dx**2)     # bord haut (simple unilatéral)
    else:
        lap = (Tw[i+1] - 2.0 * Tw[i] + Tw[i-1]) / (dx**2)
    return (qext_i - qin_i) / clamp_den(delta_w * rho_w * c_w) + (lambda_w * lap) / clamp_den(rho_w * c_w)

def dTw_dt_vap(qext_vap, qin_vap, delta_w, c_w, lambda_w,
               Tw_vap, Tw_int, rho_w, H_vap):
    """
    dTw_vap/dt (paroi côté vapeur), modèle 1D simple entre Tw_vap et Tw_int.
    """
    return ((qext_vap - qin_vap) / clamp_den(delta_w * rho_w * c_w)
            + lambda_w * (Tw_vap - Tw_int) / clamp_den(H_vap**2 * rho_w * c_w))

def dTw_dt_surface(qext_s, qin_s, delta_w, c_w, lambda_w,
               Tw_liq, rho_w, Tw_S, Tw_vap, H_S):
    """
    dTw_int/dt (paroi à la surface libre). On référence la cellule i_surface côté liquide.
    """
    return ((qext_s - qin_s) / clamp_den(delta_w * rho_w * c_w)
            + lambda_w * (Tw_S - Tw_liq - (Tw_vap - Tw_S))
            / clamp_den(H_S**2 * rho_w * c_w))


# ======================================
# Débit massique CL – version “def”
# ======================================

def dm_dot_CL_dt(i, m_dot, rho, g, alpha_v, delta, T_tilde, TB,
                 tau_w_i, C, R, dx):
    """
    d(ṁ_i)/dt dans la couche limite (Eq. 11 de Duan) :
      = 2πR [ ρ g α_v δ_i (T̃_i - TB_i) - τ_w,i ]
        - (C ṁ_i)/(2π R ρ δ_i) * [ 2 ∂ṁ/∂x - (ṁ/δ) ∂δ/∂x ]

    Discrétisation x : amont 1er ordre pour ∂/∂x.
    """
    # ---- Terme source flottabilité - frottement (AVEC le facteur R) ----
    S = 2.0 * np.pi * R * (rho * g * alpha_v * delta[i] * (T_tilde[i] - TB[i]) - tau_w_i)

    # ---- Dérivées spatiales discrètes (amont) ----
    if i == 0:
        dm_dx = (m_dot[1] - m_dot[0]) / dx
        ddelta_dx = (delta[1] - delta[0]) / dx
    else:
        dm_dx = (m_dot[i] - m_dot[i-1]) / dx
        ddelta_dx = (delta[i] - delta[i-1]) / dx

    # ---- Terme convectif (le signe "moins" est déjà dans Eq. 11) ----
    denom = 2.0 * np.pi * R * rho * max(delta[i], 1e-12)
    Conv_pref = (C * m_dot[i]) / denom
    conv_term = 2.0 * dm_dx - (m_dot[i] / max(delta[i], 1e-12)) * ddelta_dx

    return S - Conv_pref * conv_term

############################ RÉSOLUTION DU SYSTÈME ############################

# --- grandeurs dôme/interface/paroi (valeurs de départ) ---
Ti= 291.47 #K
Tw_vap = Ti  # K
Tw_s   = Ti   # K
Tv     = Ti   # K
Ts     = Ti  # K
Tint   = Ti   # K
Pv     = 800*10**3 # bar (attention aux unités si tu les utilises dans dP/dt)
q_ext  = 20.0  # W/m^2
Hs     = 0     # m

## Paramètres

Nx= 100
num_iterations= 3000

## Constantes du problèmes

R= 0.2 ## m
hauteur = 0.6 ## m
delta_w = 0.07 ## m
Nx = 30  ## Nombre de divisions de la partie fluide
M=18 ## g/mol
r=8.314/M ## Constante spécifique des gaz parfaits

dt = 1e-2  ## intervalle de temps choisi pour garantir la convergence et limiter le temps de calcul
pourcentage_remplissage= 0.85
H_vap =hauteur*(1-pourcentage_remplissage)
dx=(hauteur*pourcentage_remplissage)/(Nx+1)  ## hauteur de chaque couche de liquide
Hs=dx
Hcv=dx
qext=20
gamma= 3.56*10**5
Pref= 1.013*10**5 ## Pa
Tref= 291.47 ## temperature initiale pour l'instant


# Pour le liquide

nu_liquide = 2.07e-7
rho_liquide = 502.59
lambda_liquide = 0.097
cp_liquide = 2649.5
cv_liquide = 1640.1
alpha_v = 0.003
a_liquide = 7.6e-8
beta_liquide = 1 # A MODIFIER

# Pour la vapeur

nu_vapeur = 4.64e-7
rho_vapeur = 17.291
lambda_vapeur = 0.018
cp_vapeur = 1928.5
cv_vapeur = 1533.9

# Pour la paroi

rho_w = 7930
lambda_w = 15.24
c_w = 500


g = 9.81




# --- tableaux d'état (initialisation simple et sûre) ---
temp_bulk      = np.full(Nx, Ti)         # TB
temp_moy_cl    = np.full(Nx, Ti)          # T_tilde (T̃)
delta          = np.full(Nx, 1e-5)     # épaisseur CL (évite division par 0)
enthalpie_moy_CL = np.zeros(Nx)        # h̃ (à mettre à jour selon ton modèle)
enthalpie_y      = np.zeros(Nx)        # h_y (idem)
enthalpie_B      = np.zeros(Nx)        # h_B (idem)
m_point_CL     = np.zeros(Nx)          # ṁ_i dans la CL
m_point_y      = np.zeros(Nx)          # ṁ_vers_bulk (interface CL→bulk)
m_point_B      = np.zeros(Nx)          # ṁ dans le bulk
Tw             = np.full(Nx, Ti)         # température mur côté liquide
eta            = np.zeros(Nx)          # η = (T̃-TB)/(Tw-TB)



for it in range(num_iterations):

    # =======================
    # Cellule i = 0 (bas)
    # =======================
    i = 0
    x_i = dx/2.0  # distance murale pour corrélations locales

    # 1) flux pariétal entrant q_in au mur
    Rax_0  = Rayleigh_x(g, alpha_v, Tw[i], temp_bulk[i], x_i, nu_liquide, a_liquide)
    q_in_0 = q_in_wall(Tw[i], temp_bulk[i], Rax_0, x_i, lambda_liquide)

    # 2) mise à jour mur (dTw/dt)
    dTw_dt_0 = dTw_dt_liq(i, qext_i=q_ext, qin_i=q_in_0,
                          delta_w=delta_w, c_w=c_w, lambda_w=lambda_w,
                          Tw=Tw, rho_w=rho_w, dx=dx)
    Tw[i] += dt * dTw_dt_0

    # 3) contrainte pariétale et C (lam/turb via Gr)
    Gr_0 = Grashof_x(g, beta_liquide, Tw[i], temp_bulk[i], x_i, nu_liquide)
    ub_0 = Ub(g, beta_liquide, Tw[i], temp_bulk[i], nu_liquide)
    if Gr_0 < 1e9:
        tau_w_0 = tau_w_lam(rho_liquide, ub_0, g, beta_liquide, Tw[i], temp_bulk[i], x_i, nu_liquide)
        C_i     = 1.37
    else:
        tau_w_0 = tau_w_turb(rho_liquide, ub_0, g, beta_liquide, Tw[i], temp_bulk[i], x_i, nu_liquide)
        C_i     = 3.25

    # 4) débit massique CL (d ṁ / dt)
    dm_dt_0 = dm_dot_CL_dt(i, m_dot=m_point_CL, rho=rho_liquide, g=g, alpha_v=alpha_v,
                           delta=delta, T_tilde=temp_moy_cl, TB=temp_bulk,
                           tau_w_i=tau_w_0, C=C_i, R=R, dx=dx)
    m_point_CL[i] += dt * dm_dt_0

    # 5) énergie couche limite (dT̃/dt) + épaisseur (dδ/dt) + η
    eta_i = eta_moy(temp_moy_cl[i], temp_bulk[i], Tw[i])

    # au tout premier pas, on peut supposer dδ/dt >= 0 pour la forme simple
    ddelta_dt_guess = 0.0

    dTtilde_dt_0 = dTtilde_dt(i, eta=eta, dTw_dt=dTw_dt_0, dTB_dt=0.0,
                              Tw=Tw, TB=temp_bulk, ddelta_dt=ddelta_dt_guess,
                              m_dot=m_point_CL, m_dot_y=m_point_y,
                              h_tilde=enthalpie_moy_CL, h_y=enthalpie_y,
                              q_in_i=q_in_0, R=R, Hcv=Hcv,
                              rho=rho_liquide, cv=cv_liquide, delta_i=delta[i])

    # dδ/dt à partir de l’équation intégrale d’énergie
    ddelta_dt_0 = ddelta_dt_from_energy(i,
                                        dTtilde_dt_i=dTtilde_dt_0,
                                        m_dot=m_point_CL, m_dot_y=m_point_y,
                                        h_tilde=enthalpie_moy_CL, h_y=enthalpie_y,
                                        q_in_i=q_in_0, R=R, Hcv=Hcv,
                                        rho=rho_liquide, cv=cv_liquide,
                                        delta_i=delta[i],
                                        T_tilde_i=temp_moy_cl[i],
                                        TB_i=temp_bulk[i])

    # si érosion (dδ/dt<0), recalcul éventuel de dη/dt sinon 0
    if ddelta_dt_0 < 0.0:
        d_eta_dt_0 = d_eta_dt(i, dTtilde_dt_0, dTw_dt_0, 0.0, Tw, temp_bulk, eta_i, ddelta_dt_0)
    else:
        d_eta_dt_0 = 0.0

    # MàJ état CL
    temp_moy_cl[i] += dt * dTtilde_dt_0
    delta[i]       += dt * ddelta_dt_0
    eta[i]          = eta_i + dt * d_eta_dt_0

    # =======================
    # Balayage i = 1..Nx-1
    # =======================
    for i in range(1, Nx):
        x_i = dx/2.0 + i*dx

        # 1) flux pariétal entrant
        Rax_i  = Rayleigh_x(g, alpha_v, Tw[i], temp_bulk[i], x_i, nu_liquide, a_liquide)
        q_in_i = q_in_wall(Tw[i], temp_bulk[i], Rax_i, x_i, lambda_liquide)

        # 2) mur
        dTw_dt_i = dTw_dt_liq(i, qext_i=q_ext, qin_i=q_in_i,
                              delta_w=delta_w, c_w=c_w, lambda_w=lambda_w,
                              Tw=Tw, rho_w=rho_w, dx=dx)
        Tw[i] += dt * dTw_dt_i

        # 3) contrainte pariétale + C
        Gr_i = Grashof_x(g, beta_liquide, Tw[i], temp_bulk[i], x_i, nu_liquide)
        ub_i = Ub(g, beta_liquide, Tw[i], temp_bulk[i], nu_liquide)
        if Gr_i < 1e9:
            tau_w_i = tau_w_lam(rho_liquide, ub_i, g, beta_liquide, Tw[i], temp_bulk[i], x_i, nu_liquide)
            C_i     = 1.37
        else:
            tau_w_i = tau_w_turb(rho_liquide, ub_i, g, beta_liquide, Tw[i], temp_bulk[i], x_i, nu_liquide)
            C_i     = 3.25

        # 4) débit massique CL
        dm_dt_i = dm_dot_CL_dt(i, m_dot=m_point_CL, rho=rho_liquide, g=g, alpha_v=alpha_v,
                               delta=delta, T_tilde=temp_moy_cl, TB=temp_bulk,
                               tau_w_i=tau_w_i, C=C_i, R=R, dx=dx)
        m_point_CL[i] += dt * dm_dt_i

        # 5) énergie CL + épaisseur + η
        eta_i = eta_moy(temp_moy_cl[i], temp_bulk[i], Tw[i])

        # on réutilise le signe courant de dδ/dt (le recalculer juste après dT̃/dt)
        ddelta_dt_guess = 0.0 if it == 0 else (delta[i] - delta[i-1]) / max(dt, 1e-12)

        dTtilde_dt_i = dTtilde_dt(i, eta=eta, dTw_dt=dTw_dt_i, dTB_dt=0.0,
                                  Tw=Tw, TB=temp_bulk, ddelta_dt=ddelta_dt_guess,
                                  m_dot=m_point_CL, m_dot_y=m_point_y,
                                  h_tilde=enthalpie_moy_CL, h_y=enthalpie_y,
                                  q_in_i=q_in_i, R=R, Hcv=Hcv,
                                  rho=rho_liquide, cv=cv_liquide, delta_i=delta[i])

        ddelta_dt_i = ddelta_dt_from_energy(i,
                                            dTtilde_dt_i=dTtilde_dt_i,
                                            m_dot=m_point_CL, m_dot_y=m_point_y,
                                            h_tilde=enthalpie_moy_CL, h_y=enthalpie_y,
                                            q_in_i=q_in_i, R=R, Hcv=Hcv,
                                            rho=rho_liquide, cv=cv_liquide,
                                            delta_i=delta[i],
                                            T_tilde_i=temp_moy_cl[i],
                                            TB_i=temp_bulk[i])

        if ddelta_dt_i < 0.0:
            d_eta_dt_i = d_eta_dt(i, dTtilde_dt_i, dTw_dt_i, 0.0, Tw, temp_bulk, eta_i, ddelta_dt_i)
        else:
            d_eta_dt_i = 0.0

        temp_moy_cl[i] += dt * dTtilde_dt_i
        delta[i]       += dt * ddelta_dt_i
        eta[i]          = eta_i + dt * d_eta_dt_i

    # ================================
    # ICI: interface liquide/vapeur etc.
    # (dôme, bulk, surface) à brancher
    # ================================
    # Exemple (à adapter si tu les utilises à ce pas):
    # dTB_dt_i = dTB_dt_bulk(i, lambdaB=..., R=R, rho=rho_liquide, cv=cv_liquide,
    #                        TB=temp_bulk, delta=delta, dx=dx,
    #                        m_dot_B=m_point_B, m_dot_y=m_point_y,
    #                        h_y=enthalpie_y, h_B=enthalpie_B)
    # temp_bulk[i] += dt * dTB_dt_i

    ## SURFACE

    ### Calcul du flux de chaleur entrant
    print(Ts)
    q_in_s = k_propane_liq(Ts)*(Tw_s-Ts)
    Tw_s= Tw_s+ dt*dTw_dt_surface(qext, q_in_s, delta_w, c_w, lambda_w,Tw, rho_w, Tw_s, Tw_vap, Hs)

    ### Calcul des constantes
    Ra_vint = Rayleigh_v_int(g, alpha_v, Tv, Tint, 2*R, nu_vapeur, rho_vapeur ,cp_vapeur,lambda_vapeur)
    Ra_lint = Rayleigh_l_int(g, alpha_v, Ts, Tint, 2*R, nu_liquide, a_liquide)
    k_vint = k_v_int(Ra_vint, 2*R, lambda_vapeur)
    k_lint = k_l_int(Ra_lint, 2*R, lambda_liquide)
    m_ph = m_dot_phase(R, gamma, Tv, Ts, Tint, k_vint, k_lint)
    DHsDT=dHs_dt(m_ph, rho_liquide, R)
    Hs = max(Hs+dt*DHsDT,0)
    Ts= Ts+dt*dTs_dt_surface(Nx-1,m_point_B,enthalpie_B,m_point_CL, enthalpie_moy_CL,R, Hs,q_in_s,k_lint,Tint, Ts,delta, lambda_liquide, temp_bulk,dx,DHsDT)

    ## VAPEUR
    qin_vap = k_propane_vap(Tv)*(Tw_vap-Tv)

    dTwv_dt = dTw_dt_vap(q_ext, qin_vap, delta_w, c_w, lambda_w, Tw_vap, Tint, rho_w, H_vap)
    Tw_vap += dTwv_dt * dt

    dTv_dt_i = dTv_dt(k_propane_vap(Tv), H_vap*R, Tw_vap, Tv, k_vint, Tint, cp_vapeur, H_vap*R*1 , rho_vapeur)
    Tv += dTv_dt_i * dt

    dP_dt_i = dP_dt(Tv, m_ph, H_vap*R*1, Pv, dTv_dt_i, r, rho_liquide)
    Pv += dP_dt_i * dt

    rho_v = Pv / (r * Tv)

    ### Aprés avoir calculé la température de la vapeur on peut avoir la température de l'interface en considérant que c'est la température de saturation
    Tint=Tsat_de_P_Clausius(Pv, Pref, Tref, gamma, M)



    # BULK
    m_point_B[Nx-1] = m_point_CL[Nx-1].copy()
    for i in range (Nx-1,-1,-1):
        if i <Nx-1 :
            m_point_B[i] = m_point_B[i+1] - (m_point_CL[i]-m_point_CL[i-1])
    dTBdt_i = dTB_dt_bulk(i, lambdaB=lambda_liquide, R=R, rho=rho_liquide, cv=cv_liquide,TB=temp_bulk, delta=delta, dx=dx,m_dot_B=m_point_B, m_dot_y=m_point_y,h_y=enthalpie_y, h_B=enthalpie_B,T_top=Ts)
    temp_bulk[i] += dt * dTBdt_i